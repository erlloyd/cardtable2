# Milestone 3.6 — Yjs Performance Optimization

## Overview
Refactor YjsStore, selectors, and actions to work directly with Y.Map structures instead of converting to plain objects via `.toJSON()`. This eliminates performance bottlenecks when working with large numbers of objects (300-500+).

## Problem Statement

**Current Performance Issue:**
- `store.getAllObjects()` calls `.toJSON()` on every Y.Map, creating 300-500 new plain objects
- This conversion happens on **every store change** (drag at 30Hz = 9,000-15,000 allocations/sec)
- Selectors that query all objects are extremely expensive
- Selection tracking in routes calls `getAllObjects()` on every object change

**Root Cause:**
- Y.Map structures are not strongly typed (currently `Y.Map<Y.Map<unknown>>`)
- Type-unsafe access leads to converting entire maps to plain objects for type safety
- No caching layer - every query rebuilds the entire object map

## Proposed Solution

**Work directly with Y.Maps using typed access:**
1. Install `yjs-types` package for better TypeScript support
2. Type Y.Maps with specific property types using `TypedMap`
3. Create type-safe helper methods in YjsStore for common queries
4. Refactor selectors to work with Y.Map structures directly
5. Only call `.toJSON()` when plain objects are actually needed (rendering, API responses)

**Performance Improvements:**
- ✅ Eliminate 300-500 object allocations per query
- ✅ 50x faster selection queries (read 1 property vs convert 500 objects)
- ✅ Much lower GC pressure during high-frequency operations
- ✅ Maintain source-of-truth queries (no delta tracking fragility)

## Prerequisites
- Milestone 3.5 completed (Action system with selectors)

## Architecture Changes

### Type System
```typescript
// Install: yjs-types package
import { TypedMap } from 'yjs-types';

// Define table object properties for Y.Map
type TableObjectProps = {
  _kind: ObjectKind;
  _containerId: string | null;
  _pos: Position;
  _sortKey: string;
  _locked: boolean;
  _selectedBy: string | null;
  _meta: Record<string, unknown>;
  // Stack-specific
  _cards?: string[];
  _faceUp?: boolean;
};

// Typed Y.Map for objects
public objects: Y.Map<TypedMap<TableObjectProps>>;
```

### Store Layer
```typescript
// Type-safe property access without full conversion
getObjectProperty<K extends keyof TableObjectProps>(
  id: string,
  key: K
): TableObjectProps[K] | null

// Efficient queries that don't convert all objects
getObjectsSelectedBy(actorId: string): string[]
getObjectsByKind(kind: ObjectKind): string[]
```

### Selector Layer
```typescript
// Selectors work with Y.Map directly
export function areAllSelectedStacksExhausted(
  objectsMap: Y.Map<TypedMap<TableObjectProps>>,
  actorId: string
): boolean {
  // Read specific properties without full conversion
  objectsMap.forEach((yMap, id) => {
    const kind = yMap.get('_kind');
    const selectedBy = yMap.get('_selectedBy');
    const pos = yMap.get('_pos');
    // Only work with needed properties
  });
}
```

### Route Layer
```typescript
// Store only IDs in React state
const [selectedIds, setSelectedIds] = useState<string[]>([]);

// Update IDs efficiently
const updateSelection = () => {
  setSelectedIds(store.getObjectsSelectedBy(store.getActorId()));
};

// Convert only when needed (in useMemo)
const actionContext = useMemo(() => {
  const selectedObjects = selectedIds
    .map(id => store.getObject(id))  // ← Only converts selected objects
    .filter((obj): obj is TableObject => obj !== null);
  return buildActionContext(store, selectedIds, selectedObjects, ...);
}, [store, selectedIds, ...]);
```

## Tasks

### M3.6-T1: Install and Configure yjs-types
**Objective:** Add yjs-types package and set up type definitions.

**Dependencies:** None

**Spec:**
- Install `yjs-types` package
- Define `TableObjectProps` type for Y.Map properties
- Create type aliases for commonly used Y.Map types
- Update TypeScript configuration if needed

**Deliverables:**
- `yjs-types` added to dependencies
- Type definitions in `shared/src/index.ts`
- Type aliases in `app/src/store/types.ts`

**Test Plan:**
- TypeScript compilation passes
- No type errors in existing code

### M3.6-T2: Refactor YjsStore with Typed Y.Maps
**Objective:** Update YjsStore to use TypedMap and add type-safe query methods.

**Dependencies:** M3.6-T1

**Spec:**
- Change `objects: Y.Map<Y.Map<unknown>>` to `objects: Y.Map<TypedMap<TableObjectProps>>`
- Add `getObjectProperty<K>(id, key)` for type-safe single property access
- Add `getObjectsSelectedBy(actorId)` for efficient selection queries
- Add `getObjectsByIds(ids)` for batch conversion of specific objects
- Keep `getAllObjects()` and `getObject()` for backward compatibility (mark as deprecated)

**Deliverables:**
- Updated YjsStore with typed maps
- New type-safe query methods
- JSDoc warnings on deprecated methods
- Comprehensive JSDoc on new methods

**Test Plan:**
- All existing YjsStore tests pass
- New tests for type-safe query methods
- Performance benchmark: `getObjectsSelectedBy` vs old approach

### M3.6-T3: Refactor Selectors to Use Y.Maps
**Objective:** Update all selectors to work with Y.Map structures directly.

**Dependencies:** M3.6-T2

**Spec:**
- Update `getSelectedObjectIds` to use Y.Map iteration
- Update `areAllSelectedStacksExhausted` to read properties directly
- Update `areAllSelectedStacksReady` to read properties directly
- Add performance-focused JSDoc comments
- Keep selector signatures consistent

**Deliverables:**
- Refactored `YjsSelectors.ts` with Y.Map access
- Performance benchmarks in comments
- All selector tests passing

**Test Plan:**
- All existing selector tests pass
- Behavior unchanged (output identical)
- Performance benchmark: 50x faster on 500 objects

### M3.6-T4: Refactor Route Selection Tracking
**Objective:** Update table routes to avoid `getAllObjects()` calls.

**Dependencies:** M3.6-T3

**Spec:**
- Change `table.$id.tsx` selection tracking to use `getObjectsSelectedBy()`
- Change `dev.table.$id.tsx` selection tracking to use `getObjectsSelectedBy()`
- Store only IDs in React state (not full objects)
- Convert to full objects in useMemo when building action context
- Remove `getAllObjects()` calls from change handlers

**Deliverables:**
- Refactored selection tracking in both routes
- Updated state management patterns
- Action context built efficiently

**Test Plan:**
- Selection still works correctly
- Action context receives correct data
- E2E tests pass (selection, action handle)
- Performance: no frame drops during drag with 500 objects

### M3.6-T5: Optimize Actions and Migrations
**Objective:** Update remaining `getAllObjects()` call sites.

**Dependencies:** M3.6-T4

**Spec:**
- Refactor `generateTopSortKey()` to iterate Y.Maps directly
- Refactor `clearAllSelections()` to iterate Y.Maps directly
- Update migration code to work with Y.Maps directly where possible
- Add performance comments to remaining `.toJSON()` calls

**Deliverables:**
- Refactored YjsActions.ts functions
- Updated migrations.ts
- Performance documentation

**Test Plan:**
- All action tests pass
- Migration tests pass
- Behavior unchanged

### M3.6-T6: Performance Testing and Documentation
**Objective:** Validate performance improvements and document patterns.

**Dependencies:** M3.6-T5

**Spec:**
- Create performance benchmarks for key operations:
  - Selection queries with 500 objects
  - Drag performance at 30Hz
  - Action context building
  - Selector execution
- Document when to use `.toJSON()` vs direct Y.Map access
- Add performance guide to CLAUDE.md
- Verify GC pressure reduction in Chrome DevTools

**Deliverables:**
- Performance benchmark results
- Performance guidelines in CLAUDE.md
- Memory profiling screenshots/data

**Test Plan:**
- Run all E2E tests with 500 objects
- No frame drops during drag
- Selection queries < 1ms
- GC collections reduced by >80%

## Success Metrics

**Performance Targets:**
- Selection queries: < 1ms (currently ~20ms with 500 objects)
- Object context building: < 2ms (currently ~50ms)
- Drag at 30Hz with 500 objects: No frame drops
- GC pressure: 80%+ reduction in allocations

**Behavioral Requirements:**
- All existing tests pass
- No user-facing behavior changes
- Type safety maintained or improved
- Developer experience improved (better types, fewer conversions)

## Rollout Plan

1. **Create feature branch** from current main: `feature/m3.6-yjs-performance`
2. **Implement tasks sequentially** (T1 → T2 → T3 → T4 → T5 → T6)
3. **Test at each stage** to catch regressions early
4. **Performance testing** before and after each major change
5. **Create PR** when all tasks complete
6. **Review and merge** to main after approval

## Risks and Mitigations

**Risk:** Breaking changes to Y.Map access patterns
- **Mitigation:** Keep `.toJSON()` methods as fallback, mark deprecated

**Risk:** Type system complexity increases
- **Mitigation:** Good JSDoc, examples, and performance guides

**Risk:** Missing edge cases in Y.Map iteration
- **Mitigation:** Comprehensive test coverage, incremental rollout

**Risk:** yjs-types package maintenance concerns
- **Mitigation:** Evaluate package health, be prepared to vendor types if needed

## Notes

- This is purely a performance optimization - no user-facing features
- Keep backward compatibility during transition
- Document patterns for future development
- Consider this foundational for scaling to 1000+ objects (future milestone)
