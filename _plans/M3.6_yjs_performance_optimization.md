# Milestone 3.6 — Yjs Performance Optimization

## Overview
Refactor YjsStore, selectors, and actions to work directly with Y.Map structures instead of converting to plain objects via `.toJSON()`. This eliminates performance bottlenecks when working with large numbers of objects (300-500+).

## Problem Statement

**Current Performance Issue:**
- `store.getAllObjects()` calls `.toJSON()` on every Y.Map, creating 300-500 new plain objects
- This conversion happens on **every store change** (drag at 30Hz = 9,000-15,000 allocations/sec)
- Selectors that query all objects are extremely expensive
- Selection tracking in routes calls `getAllObjects()` on every object change

**Root Cause:**
- Y.Map structures are not strongly typed (currently `Y.Map<Y.Map<unknown>>`)
- Type-unsafe access leads to converting entire maps to plain objects for type safety
- No caching layer - every query rebuilds the entire object map

## Proposed Solution

**Work directly with Y.Maps using typed access - eliminate `.toJSON()` completely:**
1. Install `yjs-types` package for better TypeScript support
2. Type Y.Maps with specific property types using `TypedMap`
3. Create type-safe helper methods and patterns for working with Y.Maps
4. Refactor all code (store, selectors, actions, routes, renderer) to work with Y.Maps directly
5. **Remove all `.toJSON()` calls** - work exclusively with Y.Map structures

**Performance Improvements:**
- ✅ Eliminate 300-500 object allocations per query (100% reduction)
- ✅ 50x faster selection queries (read 1 property vs convert 500 objects)
- ✅ Zero GC pressure during queries (no allocations)
- ✅ Maintain source-of-truth queries (no delta tracking fragility)
- ✅ Scales to 1000+ objects without performance degradation

## Prerequisites
- Milestone 3.5 completed (Action system with selectors)

## Architecture Changes

### Type System
```typescript
// Install: yjs-types package
import { TypedMap } from 'yjs-types';

// Define table object properties for Y.Map
type TableObjectProps = {
  _kind: ObjectKind;
  _containerId: string | null;
  _pos: Position;
  _sortKey: string;
  _locked: boolean;
  _selectedBy: string | null;
  _meta: Record<string, unknown>;
  // Stack-specific
  _cards?: string[];
  _faceUp?: boolean;
};

// Typed Y.Map for objects
public objects: Y.Map<TypedMap<TableObjectProps>>;
```

### Store Layer
```typescript
// Direct Y.Map access (no conversion)
getObjectYMap(id: string): TypedMap<TableObjectProps> | null

// Type-safe property access without conversion
getObjectProperty<K extends keyof TableObjectProps>(
  id: string,
  key: K
): TableObjectProps[K] | null

// Efficient queries that work with Y.Maps directly
getObjectsSelectedBy(actorId: string): TypedMap<TableObjectProps>[]
getObjectsByKind(kind: ObjectKind): TypedMap<TableObjectProps>[]

// Helper utilities for common patterns
forEachObject(fn: (yMap: TypedMap<TableObjectProps>, id: string) => void): void
filterObjects(predicate: (yMap: TypedMap<TableObjectProps>, id: string) => boolean): string[]
```

### Selector Layer
```typescript
// Selectors work with Y.Map directly
export function areAllSelectedStacksExhausted(
  objectsMap: Y.Map<TypedMap<TableObjectProps>>,
  actorId: string
): boolean {
  // Read specific properties without full conversion
  objectsMap.forEach((yMap, id) => {
    const kind = yMap.get('_kind');
    const selectedBy = yMap.get('_selectedBy');
    const pos = yMap.get('_pos');
    // Only work with needed properties
  });
}
```

### Route Layer
```typescript
// Work with Y.Maps directly in React state
const [selectedYMaps, setSelectedYMaps] = useState<TypedMap<TableObjectProps>[]>([]);

// Update Y.Map references efficiently
const updateSelection = () => {
  setSelectedYMaps(store.getObjectsSelectedBy(store.getActorId()));
};

// Build action context with Y.Maps directly (in useMemo)
const actionContext = useMemo(() => {
  // Pass Y.Maps to action context builder - no conversion needed
  return buildActionContext(store, selectedYMaps, ...);
}, [store, selectedYMaps, ...]);
```

## Tasks

### M3.6-T1: Install and Configure yjs-types
**Objective:** Add yjs-types package and set up type definitions.

**Dependencies:** None

**Spec:**
- Install `yjs-types` package
- Define `TableObjectProps` type for Y.Map properties
- Create type aliases for commonly used Y.Map types
- Update TypeScript configuration if needed

**Deliverables:**
- `yjs-types` added to dependencies
- Type definitions in `shared/src/index.ts`
- Type aliases in `app/src/store/types.ts`

**Test Plan:**
- TypeScript compilation passes
- No type errors in existing code

### M3.6-T2: Refactor YjsStore with Typed Y.Maps
**Objective:** Update YjsStore to use TypedMap and replace all conversion methods with Y.Map-based APIs.

**Dependencies:** M3.6-T1

**Spec:**
- Change `objects: Y.Map<Y.Map<unknown>>` to `objects: Y.Map<TypedMap<TableObjectProps>>`
- Add `getObjectYMap(id)` to return Y.Map directly (replaces `getObject()`)
- Add `getObjectProperty<K>(id, key)` for type-safe single property access
- Add `getObjectsSelectedBy(actorId)` returning Y.Map array (no conversion)
- Add `getObjectsByKind(kind)` returning Y.Map array (no conversion)
- Add helper utilities: `forEachObject()`, `filterObjects()`, `mapObjects()`
- **Remove `getAllObjects()` and `getObject()` - no more `.toJSON()` calls**

**Deliverables:**
- Updated YjsStore with typed maps
- New Y.Map-based query methods
- Helper utilities for common iteration patterns
- Comprehensive JSDoc with usage examples

**Test Plan:**
- All existing YjsStore tests pass (update test assertions to work with Y.Maps)
- New tests for Y.Map-based query methods
- Performance benchmark: Zero allocations vs old approach

### M3.6-T3: Refactor Selectors to Use Y.Maps
**Objective:** Update all selectors to work with Y.Map structures directly.

**Dependencies:** M3.6-T2

**Spec:**
- Update `getSelectedObjectIds` to use Y.Map iteration
- Update `areAllSelectedStacksExhausted` to read properties directly
- Update `areAllSelectedStacksReady` to read properties directly
- Add performance-focused JSDoc comments
- Keep selector signatures consistent

**Deliverables:**
- Refactored `YjsSelectors.ts` with Y.Map access
- Performance benchmarks in comments
- All selector tests passing

**Test Plan:**
- All existing selector tests pass
- Behavior unchanged (output identical)
- Performance benchmark: 50x faster on 500 objects

### M3.6-T4: Refactor Route Selection Tracking and Action Context
**Objective:** Update table routes to work with Y.Maps directly throughout the entire flow.

**Dependencies:** M3.6-T3

**Spec:**
- Change `table.$id.tsx` selection tracking to use `getObjectsSelectedBy()` (returns Y.Maps)
- Change `dev.table.$id.tsx` selection tracking to use `getObjectsSelectedBy()` (returns Y.Maps)
- Store Y.Map references in React state (not IDs, not plain objects)
- Update `buildActionContext()` to accept Y.Maps instead of plain objects
- Update action handlers to work with Y.Maps
- Remove all `.toJSON()` calls from routes

**Deliverables:**
- Refactored selection tracking with Y.Maps in both routes
- Updated `buildActionContext()` signature and implementation
- Action handlers working with Y.Maps directly

**Test Plan:**
- Selection still works correctly
- Action context receives Y.Maps and works correctly
- E2E tests pass (selection, action handle, actions execute properly)
- Performance: no frame drops during drag with 500 objects

### M3.6-T5: Refactor Actions, Renderer, and All Remaining Code
**Objective:** Complete the Y.Map migration across the entire codebase - zero `.toJSON()` calls remaining.

**Dependencies:** M3.6-T4

**Spec:**
- Refactor `generateTopSortKey()` to iterate Y.Maps directly
- Refactor `clearAllSelections()` to iterate Y.Maps directly
- Update all YjsActions.ts functions to work with Y.Maps
- Update renderer (SceneManager, ObjectRegistry) to work with Y.Maps
- Update migrations to work with Y.Maps directly
- Search codebase for any remaining `.toJSON()` calls and eliminate them
- **Verify zero `.toJSON()` calls remain in the entire codebase**

**Deliverables:**
- Refactored YjsActions.ts (all functions)
- Updated renderer to accept Y.Maps
- Updated migrations.ts
- Grep verification: no `.toJSON()` calls in app/src

**Test Plan:**
- All unit tests pass
- All E2E tests pass
- Renderer works correctly with Y.Maps
- Actions execute properly
- Migrations apply correctly
- Performance: verified zero allocations during queries

### M3.6-T6: Performance Testing and Documentation
**Objective:** Validate performance improvements and document Y.Map patterns.

**Dependencies:** M3.6-T5

**Spec:**
- Create performance benchmarks for key operations:
  - Selection queries with 500 objects (target: < 1ms, zero allocations)
  - Drag performance at 30Hz (target: 60fps stable)
  - Action context building (target: < 2ms)
  - Selector execution (target: < 1ms)
- Document Y.Map patterns and best practices
- Add Y.Map usage guide to CLAUDE.md (property access patterns, iteration, helpers)
- Verify zero allocation queries in Chrome DevTools
- Add code examples and common patterns

**Deliverables:**
- Performance benchmark results showing 100% allocation reduction
- Y.Map development guide in CLAUDE.md
- Memory profiling data (zero allocations during queries)
- Helper function usage examples

**Test Plan:**
- Run all E2E tests with 500 objects
- No frame drops during drag (60fps stable)
- Selection queries < 1ms with zero allocations
- GC pressure eliminated (no collections during queries)
- Scales to 1000+ objects without degradation

## Success Metrics

**Performance Targets:**
- Selection queries: < 1ms with **zero allocations** (currently ~20ms with 500 allocations)
- Object context building: < 2ms with **zero allocations** (currently ~50ms with 500 allocations)
- Drag at 30Hz with 500 objects: **60fps stable, no frame drops**
- GC pressure: **100% elimination** during queries (currently massive pressure)
- Scales to 1000+ objects without performance degradation

**Behavioral Requirements:**
- All existing tests pass
- No user-facing behavior changes
- Type safety maintained with TypedMap
- Developer experience: Y.Map patterns well-documented with helper utilities

**Code Quality:**
- Zero `.toJSON()` calls in app/src (verified via grep)
- All code uses Y.Maps directly
- Helper functions reduce verbosity
- Comprehensive JSDoc and usage examples

## Rollout Plan

1. **Create feature branch** from current main: `feature/m3.6-yjs-performance`
2. **Implement tasks sequentially** (T1 → T2 → T3 → T4 → T5 → T6)
3. **Test at each stage** to catch regressions early
4. **Performance testing** before and after each major change
5. **Create PR** when all tasks complete
6. **Review and merge** to main after approval

## Risks and Mitigations

**Risk:** Breaking changes across entire codebase
- **Mitigation:** Incremental rollout (store → selectors → routes → actions → renderer), test at each stage

**Risk:** Y.Map API more verbose than plain objects
- **Mitigation:** Create helper utilities (`forEachObject`, `filterObjects`, `mapObjects`) to reduce verbosity

**Risk:** Type system complexity increases
- **Mitigation:** Comprehensive TypeScript types, JSDoc examples, and Y.Map usage guide

**Risk:** Missing edge cases in Y.Map iteration
- **Mitigation:** Comprehensive test coverage, maintain existing test behavior expectations

**Risk:** yjs-types package maintenance concerns
- **Mitigation:** Evaluate package health first, be prepared to vendor types or use custom type wrappers if needed

**Risk:** Tests need significant refactoring
- **Mitigation:** Create test utilities for Y.Map/Y.Doc creation, document test patterns

## Notes

- This is purely a performance optimization - no user-facing features
- **Zero `.toJSON()` calls** - complete Y.Map migration for maximum performance
- Helper utilities mitigate verbosity concerns
- Document Y.Map patterns extensively for future development
- Foundational for scaling to 1000+ objects (future milestone)
- Performance gains enable future features (multiplayer sync, undo/redo, large scenes)
