import { describe, it, expect, vi, beforeEach } from 'vitest';
import { StackBehaviors } from './behaviors';
import { ObjectKind, type TableObject } from '@cardtable2/shared';
import type { RenderContext } from '../types';
import { Graphics, Text, type TextOptions } from 'pixi.js';

// Helper to create test stack objects with all required properties
function createTestStack(overrides: Partial<TableObject> = {}): TableObject {
  return {
    _id: 'stack1',
    _kind: ObjectKind.Stack,
    _pos: { x: 0, y: 0, r: 0 },
    _rotation: 0,
    _containerId: null,
    _sortKey: '0',
    _locked: false,
    _selectedBy: null,
    _meta: {},
    _cards: ['card1'],
    ...overrides,
  };
}

describe('Stack Behaviors - Visual Rendering', () => {
  let mockContext: RenderContext;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let mockCreateText: any;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let mockScaleStrokeWidth: any;

  beforeEach(() => {
    mockCreateText = vi.fn((options: TextOptions) => {
      const text = new Text(options);
      text.resolution = 6; // Simulated zoom-aware resolution
      return text;
    });

    mockScaleStrokeWidth = vi.fn((baseWidth: number) => {
      // Simulate sqrt counter-scaling at 4x zoom
      // baseWidth / sqrt(4) = baseWidth / 2
      return Math.max(0.5, baseWidth / 2);
    });

    mockContext = {
      isSelected: false,
      isHovered: false,
      isDragging: false,
      cameraScale: 4.0,
      createText: mockCreateText,
      scaleStrokeWidth: mockScaleStrokeWidth,
     } as const;
  });

  describe('3D Effect Rendering', () => {
    it('renders 3D offset rectangle for stacks with 2+ cards', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2'],
      } as const;

      const graphic = StackBehaviors.render(stack, mockContext);

      expect(graphic).toBeInstanceOf(Graphics);
      // 3D effect uses counter-scaled stroke width
      expect(mockScaleStrokeWidth).toHaveBeenCalledWith(1);
    });

    it('does not render 3D effect for single-card stacks', () => {
      const singleStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
       } as const;

      const graphic = StackBehaviors.render(singleStack, mockContext);

      expect(graphic).toBeInstanceOf(Graphics);
      // Single card should call scaleStrokeWidth only once (for main border)
      // Not twice (would include 3D effect)
      const strokeCalls = mockScaleStrokeWidth.mock.calls.length;
      expect(strokeCalls).toBe(1); // Only main card border
    });

    it('3D effect stroke width counter-scales with zoom', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2'],
       } as const;

      StackBehaviors.render(stack, mockContext);

      // 3D effect should use 1px base width, counter-scaled
      expect(mockScaleStrokeWidth).toHaveBeenCalledWith(1);
    });
  });

  describe('Count Badge Rendering', () => {
    it('renders count badge for stacks with 2+ cards', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2'],
       } as const;

      StackBehaviors.render(stack, mockContext);

      // Count badge should create text showing "2"
      expect(mockCreateText).toHaveBeenCalledWith(
        expect.objectContaining({
          text: '2',
        }),
      );
    });

    it('does not render count badge for single-card stacks', () => {
      const singleStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
       } as const;

      StackBehaviors.render(singleStack, mockContext);

      // No badge text should be created for single cards
      expect(mockCreateText).not.toHaveBeenCalled();
    });

    it('count badge text uses zoom-aware resolution', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2'],
       } as const;

      StackBehaviors.render(stack, mockContext);

      // Verify createText was called (not new Text())
      expect(mockCreateText).toHaveBeenCalled();

      // Verify it was called with text options
      const call = mockCreateText.mock.calls[0];
      expect(call[0]).toHaveProperty('text');
      expect(call[0]).toHaveProperty('style');
    });

    it('count badge displays correct count for large stacks', () => {
      const largeStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: Array(52).fill('card'), // 52 cards
       } as const;

      StackBehaviors.render(largeStack, mockContext);

      expect(mockCreateText).toHaveBeenCalledWith(
        expect.objectContaining({
          text: '52',
        }),
      );
    });

    it('count badge has counter-scaled stroke width', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2'],
       } as const;

      StackBehaviors.render(stack, mockContext);

      // Badge should use 1px base width for its border
      expect(mockScaleStrokeWidth).toHaveBeenCalledWith(1);
    });
  });

  describe('Unstack Handle Rendering', () => {
    it('renders unstack handle for stacks with 2+ cards', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2'],
       } as const;

      StackBehaviors.render(stack, mockContext);

      // Unstack handle uses arrow icon
      expect(mockCreateText).toHaveBeenCalledWith(
        expect.objectContaining({
          text: '⬆',
        }),
      );
    });

    it('does not render unstack handle for single-card stacks', () => {
      const singleStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
       } as const;

      StackBehaviors.render(singleStack, mockContext);

      // No handle icon should be created
      expect(mockCreateText).not.toHaveBeenCalled();
    });

    it('unstack handle uses zoom-aware text resolution', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2'],
       } as const;

      StackBehaviors.render(stack, mockContext);

      // Verify createText was called for handle icon
      const handleCall = mockCreateText.mock.calls.find(
        (call) => (call[0] as TextOptions).text === '⬆',
      );
      expect(handleCall).toBeDefined();
    });
  });

  describe('Main Card Border', () => {
    it('uses counter-scaled stroke width for unselected cards', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
       } as const;

      StackBehaviors.render(stack, {
        ...mockContext,
        isSelected: false,
      });

      // Unselected: 2px base width
      expect(mockScaleStrokeWidth).toHaveBeenCalledWith(2);
    });

    it('uses thicker counter-scaled stroke width for selected cards', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
       } as const;

      StackBehaviors.render(stack, {
        ...mockContext,
        isSelected: true,
      });

      // Selected: 4px base width
      expect(mockScaleStrokeWidth).toHaveBeenCalledWith(4);
    });
  });

  describe('Face-Down State Rendering', () => {
    it('renders diagonal line pattern for face-down stacks', () => {
      const faceDownStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
        _faceUp: false,
       } as const;

      StackBehaviors.render(faceDownStack, mockContext);

      // Face-down pattern uses 2px base width for diagonal lines
      expect(mockScaleStrokeWidth).toHaveBeenCalledWith(2);
    });

    it('does not render diagonal pattern for face-up stacks', () => {
      const faceUpStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
        _faceUp: true,
       } as const;

      StackBehaviors.render(faceUpStack, mockContext);

      // Only one stroke call (main border), not two (would include face-down lines)
      const strokeCalls = mockScaleStrokeWidth.mock.calls.filter(
        (call) => call[0] === 2,
      );
      expect(strokeCalls.length).toBe(1); // Only main border
    });

    it('face-down pattern strokes counter-scale with zoom', () => {
      const faceDownStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
        _faceUp: false,
       } as const;

      StackBehaviors.render(faceDownStack, mockContext);

      // Pattern lines should use scaleStrokeWidth helper
      expect(mockScaleStrokeWidth).toHaveBeenCalledWith(2);
    });
  });

  describe('Complex Scenarios', () => {
    it('renders all visual elements for multi-card face-down stack', () => {
      const complexStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1', 'card2', 'card3'],
        _faceUp: false,
       } as const;

      mockScaleStrokeWidth.mockClear();
      mockCreateText.mockClear();

      StackBehaviors.render(complexStack, mockContext);

      // Should call scaleStrokeWidth for:
      // 1. 3D effect border (1px)
      // 2. Main card border (2px)
      // 3. Face-down pattern (2px)
      // 4. Badge border (1px)
      expect(mockScaleStrokeWidth).toHaveBeenCalledTimes(4);

      // Should call createText for:
      // 1. Count badge ("3")
      // 2. Unstack handle ("⬆")
      expect(mockCreateText).toHaveBeenCalledTimes(2);
    });

    it('renders minimal visuals for single face-up card', () => {
      const minimalStack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
        _faceUp: true,
       } as const;

      mockScaleStrokeWidth.mockClear();
      mockCreateText.mockClear();

      StackBehaviors.render(minimalStack, mockContext);

      // Should only call scaleStrokeWidth once (main border)
      expect(mockScaleStrokeWidth).toHaveBeenCalledTimes(1);

      // Should not call createText (no badge or handle)
      expect(mockCreateText).toHaveBeenCalledTimes(0);
    });
  });

  describe('getBounds', () => {
    it('returns correct bounds for stack', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 100, y: 200, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
       } as const;

      const bounds = StackBehaviors.getBounds(stack);

      // STACK_WIDTH = 63, STACK_HEIGHT = 88
      expect(bounds).toEqual({
        minX: 100 - 63 / 2,
        minY: 200 - 88 / 2,
        maxX: 100 + 63 / 2,
        maxY: 200 + 88 / 2,
      });
    });
  });

  describe('getShadowConfig', () => {
    it('returns correct shadow config for stack', () => {
      const stack = {
        _id: 'stack1',
        _kind: ObjectKind.Stack,
        _pos: { x: 0, y: 0, r: 0 },
        _rotation: 0,
        _cards: ['card1'],
       } as const;

      const shadowConfig = StackBehaviors.getShadowConfig(stack);

      expect(shadowConfig).toEqual({
        width: 63,
        height: 88,
        shape: 'rect',
        borderRadius: 12,
      });
    });
  });

  describe('capabilities', () => {
    it('has correct capability flags', () => {
      expect(StackBehaviors.capabilities).toEqual({
        canFlip: true,
        canRotate: true,
        canStack: true,
        canUnstack: true,
        canLock: true,
      });
    });
  });
});
